import logging
import time
import random
import string
import os
from typing import List, Dict, Any, Optional, Tuple

from mqtt_security_tester.config import Config
from mqtt_security_tester.mqtt_client_wrapper import MQTTClientWrapper

# Configure logging for this module
logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """
    Performs various vulnerability scans against an MQTT broker.
    """

    def __init__(self, config: Config):
        """
        Initializes the VulnerabilityScanner with the application configuration.

        Args:
            config (Config): The application configuration object.
        """
        self.config = config
        self.results: List[Dict[str, Any]] = []
        self.broker_host = self.config.get("broker.host")
        self.broker_port = self.config.get("broker.port")
        logger.info("VulnerabilityScanner initialized.")

    def _generate_client_id(self) -> str:
        """
        Generates a unique client ID for MQTT connections.
        """
        return 'mqtt_tester_' + ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))

    def _record_finding(self, test_name: str, severity: str, description: str, details: Optional[Dict[str, Any]] = None):
        """
        Records a security finding.
        """
        finding = {
            "test_name": test_name,
            "severity": severity,
            "description": description,
            "details": details if details is not None else {}
        }
        self.results.append(finding)
        logger.log(getattr(logging, severity.upper()), f"Finding: {test_name} - {description}")

    def test_anonymous_access(self):
        """
        Tests if the MQTT broker allows anonymous connections.
        """
        test_name = "Anonymous Access Test"
        logger.info(f"Running: {test_name}")
        client_id = self._generate_client_id()
        client = MQTTClientWrapper(client_id, self.config)
        try:
            if client.connect(username="", password=""):
                self._record_finding(
                    test_name,
                    "CRITICAL",
                    "Broker allows anonymous connections. Unauthorized access possible.",
                    {"host": self.broker_host, "port": self.broker_port}
                )
            else:
                logger.info(f"Broker at {self.broker_host}:{self.broker_port} does not allow anonymous access (expected).")
        finally:
            client.disconnect()

    def test_weak_credentials(self):
        """
        Tests for common weak usernames and passwords.
        """
        test_name = "Weak Credentials Test"
        logger.info(f"Running: {test_name}")
        weak_usernames = self.config.get("credentials.weak_usernames")
        weak_passwords = self.config.get("credentials.weak_passwords")

        for user in weak_usernames:
            for password in weak_passwords:
                client_id = self._generate_client_id()
                client = MQTTClientWrapper(client_id, self.config)
                try:
                    if client.connect(username=user, password=password):
                        self._record_finding(
                            test_name,
                            "WARNING",
                            f"Broker accepts weak credentials: {user}:{password}",
                            {"host": self.broker_host, "port": self.broker_port, "username": user, "password": password}
                        )
                        client.disconnect()
                        return # Found one, no need to continue
                finally:
                    client.disconnect()
        logger.info("No weak credentials found (from configured list).")

    def test_custom_credentials(self, username: str, password: str):
        """
        Tests a specific custom username and password.
        """
        test_name = "Custom Credentials Test"
        logger.info(f"Running: {test_name} with {username}:{password}")
        client_id = self._generate_client_id()
        client = MQTTClientWrapper(client_id, self.config)
        try:
            if client.connect(username=username, password=password):
                self._record_finding(
                    test_name,
                    "INFO",
                    f"Broker accepts custom credentials: {username}:{password}",
                    {"host": self.broker_host, "port": self.broker_port, "username": username, "password": password}
                )
            else:
                logger.info(f"Broker rejected custom credentials: {username}:{password} (expected).")
        finally:
            client.disconnect()

    def test_bruteforce_credentials(self, user_list: List[str], pass_list: List[str]):
        """
        Attempts to bruteforce credentials using provided lists.
        """
        test_name = "Bruteforce Credentials Test"
        logger.info(f"Running: {test_name} with {len(user_list)} users and {len(pass_list)} passwords.")

        for user in user_list:
            for password in pass_list:
                client_id = self._generate_client_id()
                client = MQTTClientWrapper(client_id, self.config)
                try:
                    if client.connect(username=user, password=password):
                        self._record_finding(
                            test_name,
                            "WARNING",
                            f"Broker accepts bruteforced credentials: {user}:{password}",
                            {"host": self.broker_host, "port": self.broker_port, "username": user, "password": password}
                        )
                        client.disconnect()
                        return # Found one, no need to continue
                finally:
                    client.disconnect()
        logger.info("No bruteforced credentials found.")

    def test_authorization_bypass(self, username: Optional[str] = None, password: Optional[str] = None):
        """
        Tests if a client can publish/subscribe to topics it shouldn't have access to.
        Uses configured test topics and attempts to publish/subscribe with provided credentials.
        """
        test_name = "Authorization Bypass Test"
        logger.info(f"Running: {test_name}")
        auth_test_topics = self.config.get("topics.auth_test_topics")
        publish_test_topic = self.config.get("topics.publish_test_topic")
        subscribe_test_topic = self.config.get("topics.subscribe_test_topic")

        client_id = self._generate_client_id()
        client = MQTTClientWrapper(client_id, self.config)
        if not client.connect(username=username, password=password):
            logger.warning(f"Could not connect with provided credentials {username}:{password} for auth bypass test. Skipping.")
            return

        try:
            # Test publishing to restricted topics
            for topic in auth_test_topics:
                if client.publish(topic, f"Auth bypass test message to {topic}"):
                    self._record_finding(
                        test_name,
                        "WARNING",
                        f"Client can publish to potentially restricted topic: {topic}",
                        {"host": self.broker_host, "port": self.broker_port, "action": "publish", "topic": topic}
                    )

            # Test subscribing to restricted topics
            for topic in auth_test_topics:
                if client.subscribe(topic):
                    self._record_finding(
                        test_name,
                        "WARNING",
                        f"Client can subscribe to potentially restricted topic: {topic}",
                        {"host": self.broker_host, "port": self.broker_port, "action": "subscribe", "topic": topic}
                    )

            # Test publishing to a general test topic
            if client.publish(publish_test_topic, "General publish test message"):
                logger.info(f"Successfully published to general test topic: {publish_test_topic}")
            else:
                logger.warning(f"Failed to publish to general test topic: {publish_test_topic}")

            # Test subscribing to a general test topic
            if client.subscribe(subscribe_test_topic):
                logger.info(f"Successfully subscribed to general test topic: {subscribe_test_topic}")
            else:
                logger.warning(f"Failed to subscribe to general test topic: {subscribe_test_topic}")

        finally:
            client.disconnect()

    def test_topic_enumeration(self, username: Optional[str] = None, password: Optional[str] = None):
        """
        Tests if a client can enumerate topics by subscribing to wildcard topics like '#'.
        """
        test_name = "Topic Enumeration Test"
        logger.info(f"Running: {test_name}")
        client_id = self._generate_client_id()
        client = MQTTClientWrapper(client_id, self.config)
        if not client.connect(username=username, password=password):
            logger.warning(f"Could not connect with provided credentials {username}:{password} for topic enumeration test. Skipping.")
            return

        try:
            # Subscribe to all topics using '#' wildcard
            if client.subscribe("#"):
                self._record_finding(
                    test_name,
                    "INFO",
                    "Broker allows subscription to '#' wildcard, potentially enabling topic enumeration.",
                    {"host": self.broker_host, "port": self.broker_port, "topic": "#"}
                )
                # Publish some messages to see if they are received
                test_topic = f"test/enumeration/{random.randint(1000, 9999)}"
                test_payload = "Enumeration test message"
                client.publish(test_topic, test_payload)
                time.sleep(1) # Give time for message to be received
                messages = client.get_received_messages()
                if any(m["topic"] == test_topic and m["payload"] == test_payload for m in messages):
                    logger.info(f"Successfully received message on {test_topic} via # subscription.")
                else:
                    logger.warning(f"Did not receive message on {test_topic} via # subscription.")
            else:
                logger.info("Broker does not allow subscription to '#' wildcard (expected).")
        finally:
            client.disconnect()

    def test_retained_messages(self, username: Optional[str] = None, password: Optional[str] = None):
        """
        Tests for sensitive information in retained messages.
        Publishes a retained message and then subscribes to see if it's received.
        """
        test_name = "Retained Message Test"
        logger.info(f"Running: {test_name}")
        retained_test_topic = self.config.get("topics.retained_test_topic")
        sensitive_payload = f"SECRET_KEY={os.urandom(16).hex()}"

        # Client to publish retained message
        publisher_client_id = self._generate_client_id()
        publisher_client = MQTTClientWrapper(publisher_client_id, self.config)
        if not publisher_client.connect(username=username, password=password):
            logger.warning(f"Could not connect publisher with provided credentials {username}:{password} for retained message test. Skipping.")
            return

        try:
            publisher_client.publish(retained_test_topic, sensitive_payload, qos=1, retain=True)
            logger.info(f"Published retained message to {retained_test_topic}.")
            publisher_client.disconnect()

            time.sleep(1) # Give broker time to process retained message

            # New client to subscribe and check for retained message
            subscriber_client_id = self._generate_client_id()
            subscriber_client = MQTTClientWrapper(subscriber_client_id, self.config)
            if not subscriber_client.connect(username=username, password=password):
                logger.warning(f"Could not connect subscriber with provided credentials {username}:{password} for retained message test. Skipping.")
                return

            try:
                if subscriber_client.subscribe(retained_test_topic):
                    time.sleep(1) # Give time for retained message to be received
                    messages = subscriber_client.get_received_messages()
                    found_retained = False
                    for msg in messages:
                        if msg["topic"] == retained_test_topic and msg["retain"] and msg["payload"] == sensitive_payload:
                            self._record_finding(
                                test_name,
                                "INFO",
                                f"Sensitive information found in retained message on topic: {retained_test_topic}",
                                {"host": self.broker_host, "port": self.broker_port, "topic": retained_test_topic, "payload": sensitive_payload}
                            )
                            found_retained = True
                            break
                    if not found_retained:
                        logger.info(f"No sensitive retained message found on {retained_test_topic} (expected).")
                else:
                    logger.warning(f"Failed to subscribe to {retained_test_topic} for retained message test.")
            finally:
                subscriber_client.disconnect()

        finally:
            # Clean up the retained message by publishing an empty message with retain=True
            cleanup_client_id = self._generate_client_id()
            cleanup_client = MQTTClientWrapper(cleanup_client_id, self.config)
            if cleanup_client.connect(username=username, password=password):
                cleanup_client.publish(retained_test_topic, "", qos=1, retain=True)
                logger.info(f"Cleaned up retained message on {retained_test_topic}.")
            cleanup_client.disconnect()

    def test_lwt_abuse(self, username: Optional[str] = None, password: Optional[str] = None):
        """
        Tests if Last Will and Testament (LWT) messages can be abused.
        This test sets an LWT message and then simulates an unclean disconnect.
        It then checks if the LWT message was published.
        """
        test_name = "LWT Abuse Test"
        logger.info(f"Running: {test_name}")
        lwt_test_topic = self.config.get("topics.lwt_test_topic")
        lwt_payload = f"LWT_TRIGGERED_BY_TEST_{random.randint(1000, 9999)}"

        # Client to set LWT and then disconnect uncleanly
        lwt_setter_client_id = self._generate_client_id()
        lwt_setter_client = MQTTClientWrapper(lwt_setter_client_id, self.config, clean_session=False)
        lwt_setter_client.set_will(lwt_test_topic, lwt_payload, qos=1, retain=False)

        # Client to subscribe and check for LWT message
        lwt_checker_client_id = self._generate_client_id()
        lwt_checker_client = MQTTClientWrapper(lwt_checker_client_id, self.config)

        if not lwt_checker_client.connect(username=username, password=password):
            logger.warning(f"Could not connect LWT checker with provided credentials {username}:{password}. Skipping.")
            return

        try:
            if not lwt_checker_client.subscribe(lwt_test_topic):
                logger.warning(f"Failed to subscribe to LWT topic {lwt_test_topic}. Skipping LWT test.")
                return

            if not lwt_setter_client.connect(username=username, password=password):
                logger.warning(f"Could not connect LWT setter with provided credentials {username}:{password}. Skipping.")
                return

            logger.info("LWT setter client connected. Simulating unclean disconnect...")
            # Simulate unclean disconnect by stopping the loop without calling client.disconnect()
            lwt_setter_client.client.loop_stop()
            # Force close the socket to simulate network failure
            if lwt_setter_client.client.socket() is not None:
                lwt_setter_client.client.socket().close()
            lwt_setter_client.is_connected = False # Manually update state

            time.sleep(2) # Give broker time to publish LWT

            messages = lwt_checker_client.get_received_messages()
            found_lwt = False
            for msg in messages:
                if msg["topic"] == lwt_test_topic and msg["payload"] == lwt_payload:
                    self._record_finding(
                        test_name,
                        "INFO",
                        f"LWT message '{lwt_payload}' published on topic {lwt_test_topic} after unclean disconnect.",
                        {"host": self.broker_host, "port": self.broker_port, "topic": lwt_test_topic, "payload": lwt_payload}
                    )
                    found_lwt = True
                    break
            if not found_lwt:
                logger.info(f"LWT message was not published on {lwt_test_topic} (expected if LWT is properly restricted).")

        finally:
            lwt_checker_client.disconnect()

    def run_all_scans(self, username: Optional[str] = None, password: Optional[str] = None):
        """
        Runs all configured vulnerability scans.
        """
        logger.info("Starting all vulnerability scans...")
        if self.config.get("scan_options.test_anonymous_access"):
            self.test_anonymous_access()
        if self.config.get("scan_options.test_weak_credentials"):
            self.test_weak_credentials()
        if self.config.get("scan_options.test_authorization_bypass"):
            self.test_authorization_bypass(username, password)
        if self.config.get("scan_options.test_topic_enumeration"):
            self.test_topic_enumeration(username, password)
        if self.config.get("scan_options.test_retained_messages"):
            self.test_retained_messages(username, password)
        if self.config.get("scan_options.test_lwt"):
            self.test_lwt_abuse(username, password)
        logger.info("All vulnerability scans completed.")

    def get_results(self) -> List[Dict[str, Any]]:
        """
        Returns the list of findings from the scans.
        """
        return self.results

# Example Usage (for direct testing/demonstration)
if __name__ == "__main__":
    import sys
    import os

    # Setup basic logging for example
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Ensure config is loaded (adjust path if needed for direct run)
    try:
        config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'config', 'settings.toml')
        app_config = Config(config_path=config_path)
    except Exception as e:
        print(f"Error loading configuration: {e}", file=sys.stderr)
        sys.exit(1)

    print("\n--- Vulnerability Scanner Demonstration ---")

    scanner = VulnerabilityScanner(app_config)

    # Run all scans (adjust config/settings.toml to enable/disable specific tests)
    scanner.run_all_scans(username="testuser", password="testpass") # Provide valid credentials if broker requires it

    print("\n--- Scan Results ---")
    results = scanner.get_results()
    if results:
        for finding in results:
            print(f"[{finding['severity']}] {finding['test_name']}: {finding['description']}")
            if finding['details']:
                for key, value in finding['details'].items():
                    print(f"  {key}: {value}")
    else:
        print("No vulnerabilities found.")
